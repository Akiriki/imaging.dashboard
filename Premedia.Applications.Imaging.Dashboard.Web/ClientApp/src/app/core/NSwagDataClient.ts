//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IActivityClient {
    getActivityById(id: string | undefined): Observable<ActivityReadModel>;
    getAllActivities(): Observable<ActivityReadModel[]>;
    createActivity(command: CreateActivityCommand): Observable<ActivityReadModel>;
    updateActivity(command: UpdateActivityCommand): Observable<ActivityReadModel>;
    deleteActivity(id: string | undefined): Observable<ActivityReadModel>;
}

@Injectable({
    providedIn: 'root'
})
export class ActivityClient implements IActivityClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7113";
    }

    getActivityById(id: string | undefined): Observable<ActivityReadModel> {
        let url_ = this.baseUrl + "/Activity/GetActivityById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActivityById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActivityById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActivityReadModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActivityReadModel>;
        }));
    }

    protected processGetActivityById(response: HttpResponseBase): Observable<ActivityReadModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityReadModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllActivities(): Observable<ActivityReadModel[]> {
        let url_ = this.baseUrl + "/Activity/GetAllActivities";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllActivities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllActivities(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActivityReadModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActivityReadModel[]>;
        }));
    }

    protected processGetAllActivities(response: HttpResponseBase): Observable<ActivityReadModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ActivityReadModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createActivity(command: CreateActivityCommand): Observable<ActivityReadModel> {
        let url_ = this.baseUrl + "/Activity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateActivity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActivityReadModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActivityReadModel>;
        }));
    }

    protected processCreateActivity(response: HttpResponseBase): Observable<ActivityReadModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityReadModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateActivity(command: UpdateActivityCommand): Observable<ActivityReadModel> {
        let url_ = this.baseUrl + "/Activity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateActivity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActivityReadModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActivityReadModel>;
        }));
    }

    protected processUpdateActivity(response: HttpResponseBase): Observable<ActivityReadModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityReadModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteActivity(id: string | undefined): Observable<ActivityReadModel> {
        let url_ = this.baseUrl + "/Activity?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteActivity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActivityReadModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActivityReadModel>;
        }));
    }

    protected processDeleteActivity(response: HttpResponseBase): Observable<ActivityReadModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActivityReadModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IApplicationFilesClient {
    getAdditionalFileById(id: string | undefined): Observable<AdditionalFileReadModel>;
    getAllAdditionalFiles(): Observable<AdditionalFileReadModel[]>;
    createAdditionalFile(command: CreateAdditionalFileCommand): Observable<AdditionalFileReadModel>;
    updateAdditionalFile(command: UpdateAdditionalFileCommand): Observable<AdditionalFileReadModel>;
}

@Injectable({
    providedIn: 'root'
})
export class ApplicationFilesClient implements IApplicationFilesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7113";
    }

    getAdditionalFileById(id: string | undefined): Observable<AdditionalFileReadModel> {
        let url_ = this.baseUrl + "/ApplicationFiles/GetAdditionalFileById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdditionalFileById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdditionalFileById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdditionalFileReadModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdditionalFileReadModel>;
        }));
    }

    protected processGetAdditionalFileById(response: HttpResponseBase): Observable<AdditionalFileReadModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdditionalFileReadModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllAdditionalFiles(): Observable<AdditionalFileReadModel[]> {
        let url_ = this.baseUrl + "/ApplicationFiles/GetAllAdditionalFiles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAdditionalFiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAdditionalFiles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdditionalFileReadModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdditionalFileReadModel[]>;
        }));
    }

    protected processGetAllAdditionalFiles(response: HttpResponseBase): Observable<AdditionalFileReadModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AdditionalFileReadModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createAdditionalFile(command: CreateAdditionalFileCommand): Observable<AdditionalFileReadModel> {
        let url_ = this.baseUrl + "/ApplicationFiles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAdditionalFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAdditionalFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdditionalFileReadModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdditionalFileReadModel>;
        }));
    }

    protected processCreateAdditionalFile(response: HttpResponseBase): Observable<AdditionalFileReadModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdditionalFileReadModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateAdditionalFile(command: UpdateAdditionalFileCommand): Observable<AdditionalFileReadModel> {
        let url_ = this.baseUrl + "/ApplicationFiles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAdditionalFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAdditionalFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AdditionalFileReadModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AdditionalFileReadModel>;
        }));
    }

    protected processUpdateAdditionalFile(response: HttpResponseBase): Observable<AdditionalFileReadModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdditionalFileReadModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IClientClient {
    getAllClients(): Observable<ClientReadModel[]>;
    getClientById(id: string | undefined): Observable<ClientReadModel>;
    createClient(command: CreateClientCommand): Observable<ClientReadModel>;
    updateClient(command: UpdateClientCommand): Observable<ClientReadModel>;
}

@Injectable({
    providedIn: 'root'
})
export class ClientClient implements IClientClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7113";
    }

    getAllClients(): Observable<ClientReadModel[]> {
        let url_ = this.baseUrl + "/Client/GetAllClients";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllClients(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllClients(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientReadModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientReadModel[]>;
        }));
    }

    protected processGetAllClients(response: HttpResponseBase): Observable<ClientReadModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClientReadModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getClientById(id: string | undefined): Observable<ClientReadModel> {
        let url_ = this.baseUrl + "/Client/GetClientById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClientById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClientById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientReadModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientReadModel>;
        }));
    }

    protected processGetClientById(response: HttpResponseBase): Observable<ClientReadModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientReadModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createClient(command: CreateClientCommand): Observable<ClientReadModel> {
        let url_ = this.baseUrl + "/Client";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateClient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateClient(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientReadModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientReadModel>;
        }));
    }

    protected processCreateClient(response: HttpResponseBase): Observable<ClientReadModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientReadModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateClient(command: UpdateClientCommand): Observable<ClientReadModel> {
        let url_ = this.baseUrl + "/Client";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateClient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateClient(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientReadModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientReadModel>;
        }));
    }

    protected processUpdateClient(response: HttpResponseBase): Observable<ClientReadModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientReadModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IHistoryClient {
    getChangedHistories(): Observable<HistoryReadModel[]>;
    getHistoryById(id: string | undefined): Observable<HistoryReadModel>;
    getAllHistories(): Observable<HistoryReadModel[]>;
    createHistory(command: CreateHistoryCommand): Observable<HistoryReadModel>;
    getHistoriesByJobId(id: string | undefined): Observable<HistoryReadModel[]>;
    updateHistory(command: UpdateHistoryCommand): Observable<HistoryReadModel>;
}

@Injectable({
    providedIn: 'root'
})
export class HistoryClient implements IHistoryClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7113";
    }

    getChangedHistories(): Observable<HistoryReadModel[]> {
        let url_ = this.baseUrl + "/History/GetChangedHistories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetChangedHistories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChangedHistories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HistoryReadModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HistoryReadModel[]>;
        }));
    }

    protected processGetChangedHistories(response: HttpResponseBase): Observable<HistoryReadModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(HistoryReadModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getHistoryById(id: string | undefined): Observable<HistoryReadModel> {
        let url_ = this.baseUrl + "/History/GetHistoryById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHistoryById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHistoryById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HistoryReadModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HistoryReadModel>;
        }));
    }

    protected processGetHistoryById(response: HttpResponseBase): Observable<HistoryReadModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HistoryReadModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllHistories(): Observable<HistoryReadModel[]> {
        let url_ = this.baseUrl + "/History/GetAllHistories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllHistories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllHistories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HistoryReadModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HistoryReadModel[]>;
        }));
    }

    protected processGetAllHistories(response: HttpResponseBase): Observable<HistoryReadModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(HistoryReadModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createHistory(command: CreateHistoryCommand): Observable<HistoryReadModel> {
        let url_ = this.baseUrl + "/History/GetAllHistories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HistoryReadModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HistoryReadModel>;
        }));
    }

    protected processCreateHistory(response: HttpResponseBase): Observable<HistoryReadModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HistoryReadModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getHistoriesByJobId(id: string | undefined): Observable<HistoryReadModel[]> {
        let url_ = this.baseUrl + "/History/GetHistoriesByJobId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHistoriesByJobId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHistoriesByJobId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HistoryReadModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HistoryReadModel[]>;
        }));
    }

    protected processGetHistoriesByJobId(response: HttpResponseBase): Observable<HistoryReadModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(HistoryReadModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateHistory(command: UpdateHistoryCommand): Observable<HistoryReadModel> {
        let url_ = this.baseUrl + "/History";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HistoryReadModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HistoryReadModel>;
        }));
    }

    protected processUpdateHistory(response: HttpResponseBase): Observable<HistoryReadModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HistoryReadModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IJobClient {
    getNewJobs(): Observable<JobReadModel[]>;
    getAllJobs(): Observable<JobReadModel[]>;
    getJobById(id: string | undefined): Observable<JobReadModel>;
    getJobsByEditor(editor: User): Observable<JobReadModel[]>;
    getOpenJobsByEditorId(id: string | undefined): Observable<JobReadModel[]>;
    getOpenColleagueJobs(id: string | undefined): Observable<JobReadModel[]>;
    getTransferredJobs(): Observable<JobReadModel[]>;
    getDoneJobs(): Observable<JobReadModel[]>;
    createJob(command: CreateJobCommand): Observable<JobReadModel>;
    updateJob(command: UpdateJobCommand): Observable<JobReadModel>;
    changeEditor(command: UpdateJobEditorCommand): Observable<JobReadModel>;
}

@Injectable({
    providedIn: 'root'
})
export class JobClient implements IJobClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7113";
    }

    getNewJobs(): Observable<JobReadModel[]> {
        let url_ = this.baseUrl + "/Job/GetNewJobs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewJobs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewJobs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobReadModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobReadModel[]>;
        }));
    }

    protected processGetNewJobs(response: HttpResponseBase): Observable<JobReadModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(JobReadModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllJobs(): Observable<JobReadModel[]> {
        let url_ = this.baseUrl + "/Job/GetAllJobs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllJobs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllJobs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobReadModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobReadModel[]>;
        }));
    }

    protected processGetAllJobs(response: HttpResponseBase): Observable<JobReadModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(JobReadModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getJobById(id: string | undefined): Observable<JobReadModel> {
        let url_ = this.baseUrl + "/Job/GetJobById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJobById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJobById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobReadModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobReadModel>;
        }));
    }

    protected processGetJobById(response: HttpResponseBase): Observable<JobReadModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobReadModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getJobsByEditor(editor: User): Observable<JobReadModel[]> {
        let url_ = this.baseUrl + "/Job/GetJobsByEditor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(editor);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJobsByEditor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJobsByEditor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobReadModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobReadModel[]>;
        }));
    }

    protected processGetJobsByEditor(response: HttpResponseBase): Observable<JobReadModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(JobReadModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOpenJobsByEditorId(id: string | undefined): Observable<JobReadModel[]> {
        let url_ = this.baseUrl + "/Job/GetOpenJobsByEditorId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOpenJobsByEditorId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOpenJobsByEditorId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobReadModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobReadModel[]>;
        }));
    }

    protected processGetOpenJobsByEditorId(response: HttpResponseBase): Observable<JobReadModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(JobReadModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOpenColleagueJobs(id: string | undefined): Observable<JobReadModel[]> {
        let url_ = this.baseUrl + "/Job/GetOpenColleagueJobs?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOpenColleagueJobs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOpenColleagueJobs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobReadModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobReadModel[]>;
        }));
    }

    protected processGetOpenColleagueJobs(response: HttpResponseBase): Observable<JobReadModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(JobReadModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTransferredJobs(): Observable<JobReadModel[]> {
        let url_ = this.baseUrl + "/Job/GetTransferredJobs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransferredJobs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransferredJobs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobReadModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobReadModel[]>;
        }));
    }

    protected processGetTransferredJobs(response: HttpResponseBase): Observable<JobReadModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(JobReadModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getDoneJobs(): Observable<JobReadModel[]> {
        let url_ = this.baseUrl + "/Job/GetDoneJobs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDoneJobs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDoneJobs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobReadModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobReadModel[]>;
        }));
    }

    protected processGetDoneJobs(response: HttpResponseBase): Observable<JobReadModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(JobReadModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createJob(command: CreateJobCommand): Observable<JobReadModel> {
        let url_ = this.baseUrl + "/Job";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateJob(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateJob(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobReadModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobReadModel>;
        }));
    }

    protected processCreateJob(response: HttpResponseBase): Observable<JobReadModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobReadModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateJob(command: UpdateJobCommand): Observable<JobReadModel> {
        let url_ = this.baseUrl + "/Job";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateJob(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateJob(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobReadModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobReadModel>;
        }));
    }

    protected processUpdateJob(response: HttpResponseBase): Observable<JobReadModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobReadModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    changeEditor(command: UpdateJobEditorCommand): Observable<JobReadModel> {
        let url_ = this.baseUrl + "/Job/ChangeEditor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeEditor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeEditor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobReadModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobReadModel>;
        }));
    }

    protected processChangeEditor(response: HttpResponseBase): Observable<JobReadModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobReadModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IJobFileClient {
    getNewJobFiles(): Observable<JobFileReadModel[]>;
    getAllJobFiles(): Observable<JobFileReadModel[]>;
    getJobFilesById(id: string | undefined): Observable<JobFileReadModel>;
    getJobFilesByJobId(id: string | undefined): Observable<JobFileReadModel[]>;
    getTransferredJobFiles(): Observable<JobFileReadModel[]>;
    createJobFile(command: CreateJobFileCommand): Observable<JobFileReadModel>;
    updateJobFile(command: UpdateJobFileCommand): Observable<JobFileReadModel>;
}

@Injectable({
    providedIn: 'root'
})
export class JobFileClient implements IJobFileClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7113";
    }

    getNewJobFiles(): Observable<JobFileReadModel[]> {
        let url_ = this.baseUrl + "/JobFile/GetNewJobFiles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewJobFiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewJobFiles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobFileReadModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobFileReadModel[]>;
        }));
    }

    protected processGetNewJobFiles(response: HttpResponseBase): Observable<JobFileReadModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(JobFileReadModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllJobFiles(): Observable<JobFileReadModel[]> {
        let url_ = this.baseUrl + "/JobFile/GetAllJobFiles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllJobFiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllJobFiles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobFileReadModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobFileReadModel[]>;
        }));
    }

    protected processGetAllJobFiles(response: HttpResponseBase): Observable<JobFileReadModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(JobFileReadModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getJobFilesById(id: string | undefined): Observable<JobFileReadModel> {
        let url_ = this.baseUrl + "/JobFile/GetJobFilesById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJobFilesById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJobFilesById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobFileReadModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobFileReadModel>;
        }));
    }

    protected processGetJobFilesById(response: HttpResponseBase): Observable<JobFileReadModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobFileReadModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getJobFilesByJobId(id: string | undefined): Observable<JobFileReadModel[]> {
        let url_ = this.baseUrl + "/JobFile/GetJobFilesByJobId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJobFilesByJobId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJobFilesByJobId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobFileReadModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobFileReadModel[]>;
        }));
    }

    protected processGetJobFilesByJobId(response: HttpResponseBase): Observable<JobFileReadModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(JobFileReadModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTransferredJobFiles(): Observable<JobFileReadModel[]> {
        let url_ = this.baseUrl + "/JobFile/GetTransferredJobFiles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransferredJobFiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransferredJobFiles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobFileReadModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobFileReadModel[]>;
        }));
    }

    protected processGetTransferredJobFiles(response: HttpResponseBase): Observable<JobFileReadModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(JobFileReadModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createJobFile(command: CreateJobFileCommand): Observable<JobFileReadModel> {
        let url_ = this.baseUrl + "/JobFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateJobFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateJobFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobFileReadModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobFileReadModel>;
        }));
    }

    protected processCreateJobFile(response: HttpResponseBase): Observable<JobFileReadModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobFileReadModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateJobFile(command: UpdateJobFileCommand): Observable<JobFileReadModel> {
        let url_ = this.baseUrl + "/JobFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateJobFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateJobFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JobFileReadModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JobFileReadModel>;
        }));
    }

    protected processUpdateJobFile(response: HttpResponseBase): Observable<JobFileReadModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JobFileReadModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITimeTrackingClient {
    getTimeTrackingsByEditor(editor: User): Observable<TimeTrackingReadModel[]>;
    getAllTimeTrackings(): Observable<TimeTrackingReadModel[]>;
    getTimeTrackingById(id: string | undefined): Observable<TimeTrackingReadModel>;
    createTimeTracking(command: CreateTimeTrackingCommand): Observable<TimeTrackingReadModel>;
    updateTimeTracking(command: UpdateTimeTrackingCommand): Observable<TimeTrackingReadModel>;
}

@Injectable({
    providedIn: 'root'
})
export class TimeTrackingClient implements ITimeTrackingClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7113";
    }

    getTimeTrackingsByEditor(editor: User): Observable<TimeTrackingReadModel[]> {
        let url_ = this.baseUrl + "/TimeTracking/GetTimeTrackingsByEditor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(editor);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimeTrackingsByEditor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimeTrackingsByEditor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TimeTrackingReadModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TimeTrackingReadModel[]>;
        }));
    }

    protected processGetTimeTrackingsByEditor(response: HttpResponseBase): Observable<TimeTrackingReadModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TimeTrackingReadModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllTimeTrackings(): Observable<TimeTrackingReadModel[]> {
        let url_ = this.baseUrl + "/TimeTracking/GetAllTimeTrackings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTimeTrackings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTimeTrackings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TimeTrackingReadModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TimeTrackingReadModel[]>;
        }));
    }

    protected processGetAllTimeTrackings(response: HttpResponseBase): Observable<TimeTrackingReadModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TimeTrackingReadModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTimeTrackingById(id: string | undefined): Observable<TimeTrackingReadModel> {
        let url_ = this.baseUrl + "/TimeTracking/GetTimeTrackingById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimeTrackingById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimeTrackingById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TimeTrackingReadModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TimeTrackingReadModel>;
        }));
    }

    protected processGetTimeTrackingById(response: HttpResponseBase): Observable<TimeTrackingReadModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TimeTrackingReadModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createTimeTracking(command: CreateTimeTrackingCommand): Observable<TimeTrackingReadModel> {
        let url_ = this.baseUrl + "/TimeTracking";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTimeTracking(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTimeTracking(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TimeTrackingReadModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TimeTrackingReadModel>;
        }));
    }

    protected processCreateTimeTracking(response: HttpResponseBase): Observable<TimeTrackingReadModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TimeTrackingReadModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateTimeTracking(command: UpdateTimeTrackingCommand): Observable<TimeTrackingReadModel> {
        let url_ = this.baseUrl + "/TimeTracking";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTimeTracking(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTimeTracking(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TimeTrackingReadModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TimeTrackingReadModel>;
        }));
    }

    protected processUpdateTimeTracking(response: HttpResponseBase): Observable<TimeTrackingReadModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TimeTrackingReadModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IUserClient {
    getAllUsers(): Observable<UserReadModel[]>;
    getUserById(id: string | undefined): Observable<UserReadModel>;
    createUser(command: CreateUserCommand): Observable<UserReadModel>;
    updateUser(command: UpdateUserCommand): Observable<UserReadModel>;
}

@Injectable({
    providedIn: 'root'
})
export class UserClient implements IUserClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7113";
    }

    getAllUsers(): Observable<UserReadModel[]> {
        let url_ = this.baseUrl + "/User/GetAllUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserReadModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserReadModel[]>;
        }));
    }

    protected processGetAllUsers(response: HttpResponseBase): Observable<UserReadModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserReadModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUserById(id: string | undefined): Observable<UserReadModel> {
        let url_ = this.baseUrl + "/User/GetUserById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserReadModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserReadModel>;
        }));
    }

    protected processGetUserById(response: HttpResponseBase): Observable<UserReadModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserReadModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createUser(command: CreateUserCommand): Observable<UserReadModel> {
        let url_ = this.baseUrl + "/User";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserReadModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserReadModel>;
        }));
    }

    protected processCreateUser(response: HttpResponseBase): Observable<UserReadModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserReadModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateUser(command: UpdateUserCommand): Observable<UserReadModel> {
        let url_ = this.baseUrl + "/User";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserReadModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserReadModel>;
        }));
    }

    protected processUpdateUser(response: HttpResponseBase): Observable<UserReadModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserReadModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IWeatherForecastClient {
    get(): Observable<WeatherForecast[]>;
}

@Injectable({
    providedIn: 'root'
})
export class WeatherForecastClient implements IWeatherForecastClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7113";
    }

    get(): Observable<WeatherForecast[]> {
        let url_ = this.baseUrl + "/WeatherForecast";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WeatherForecast[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WeatherForecast[]>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WeatherForecast[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherForecast.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class ActivityReadModel implements IActivityReadModel {
    id?: string;
    createdAt?: Date;
    customer?: string;
    serviceType?: string;
    quality?: string;

    constructor(data?: IActivityReadModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.customer = _data["customer"];
            this.serviceType = _data["serviceType"];
            this.quality = _data["quality"];
        }
    }

    static fromJS(data: any): ActivityReadModel {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityReadModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["customer"] = this.customer;
        data["serviceType"] = this.serviceType;
        data["quality"] = this.quality;
        return data;
    }
}

export interface IActivityReadModel {
    id?: string;
    createdAt?: Date;
    customer?: string;
    serviceType?: string;
    quality?: string;
}

export class CreateActivityCommand implements ICreateActivityCommand {
    id?: string;
    customer?: string;
    serviceType?: string;
    quality?: string;

    constructor(data?: ICreateActivityCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.customer = _data["customer"];
            this.serviceType = _data["serviceType"];
            this.quality = _data["quality"];
        }
    }

    static fromJS(data: any): CreateActivityCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateActivityCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customer"] = this.customer;
        data["serviceType"] = this.serviceType;
        data["quality"] = this.quality;
        return data;
    }
}

export interface ICreateActivityCommand {
    id?: string;
    customer?: string;
    serviceType?: string;
    quality?: string;
}

export class UpdateActivityCommand implements IUpdateActivityCommand {
    id?: string;
    customer?: string;
    serviceType?: string;
    quality?: string;

    constructor(data?: IUpdateActivityCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.customer = _data["customer"];
            this.serviceType = _data["serviceType"];
            this.quality = _data["quality"];
        }
    }

    static fromJS(data: any): UpdateActivityCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateActivityCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customer"] = this.customer;
        data["serviceType"] = this.serviceType;
        data["quality"] = this.quality;
        return data;
    }
}

export interface IUpdateActivityCommand {
    id?: string;
    customer?: string;
    serviceType?: string;
    quality?: string;
}

export class AdditionalFileReadModel implements IAdditionalFileReadModel {
    id?: string;
    createdAt?: Date;
    title?: string;

    constructor(data?: IAdditionalFileReadModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): AdditionalFileReadModel {
        data = typeof data === 'object' ? data : {};
        let result = new AdditionalFileReadModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["title"] = this.title;
        return data;
    }
}

export interface IAdditionalFileReadModel {
    id?: string;
    createdAt?: Date;
    title?: string;
}

export class CreateAdditionalFileCommand implements ICreateAdditionalFileCommand {
    title?: string;

    constructor(data?: ICreateAdditionalFileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): CreateAdditionalFileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAdditionalFileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        return data;
    }
}

export interface ICreateAdditionalFileCommand {
    title?: string;
}

export class UpdateAdditionalFileCommand implements IUpdateAdditionalFileCommand {
    id?: string;
    title?: string;

    constructor(data?: IUpdateAdditionalFileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): UpdateAdditionalFileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAdditionalFileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        return data;
    }
}

export interface IUpdateAdditionalFileCommand {
    id?: string;
    title?: string;
}

export class ClientReadModel implements IClientReadModel {
    id?: string;
    createdAt?: Date;
    email?: string;
    shortcut?: string;
    firstName?: string;
    lastName?: string;

    constructor(data?: IClientReadModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.email = _data["email"];
            this.shortcut = _data["shortcut"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
        }
    }

    static fromJS(data: any): ClientReadModel {
        data = typeof data === 'object' ? data : {};
        let result = new ClientReadModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["email"] = this.email;
        data["shortcut"] = this.shortcut;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        return data;
    }
}

export interface IClientReadModel {
    id?: string;
    createdAt?: Date;
    email?: string;
    shortcut?: string;
    firstName?: string;
    lastName?: string;
}

export class CreateClientCommand implements ICreateClientCommand {
    email?: string;
    shortcut?: string;
    firstName?: string;
    lastName?: string;

    constructor(data?: ICreateClientCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.shortcut = _data["shortcut"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
        }
    }

    static fromJS(data: any): CreateClientCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateClientCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["shortcut"] = this.shortcut;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        return data;
    }
}

export interface ICreateClientCommand {
    email?: string;
    shortcut?: string;
    firstName?: string;
    lastName?: string;
}

export class UpdateClientCommand implements IUpdateClientCommand {
    id?: string;
    email?: string;
    shortcut?: string;
    firstName?: string;
    lastName?: string;

    constructor(data?: IUpdateClientCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.email = _data["email"];
            this.shortcut = _data["shortcut"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
        }
    }

    static fromJS(data: any): UpdateClientCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateClientCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        data["shortcut"] = this.shortcut;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        return data;
    }
}

export interface IUpdateClientCommand {
    id?: string;
    email?: string;
    shortcut?: string;
    firstName?: string;
    lastName?: string;
}

export class HistoryReadModel implements IHistoryReadModel {
    id?: string;
    createdAt?: Date;
    action?: string;
    field?: string;
    errorCode?: string;
    oldValue?: string;
    newValue?: string | undefined;
    changeTime?: Date;
    job?: JobReadModel;

    constructor(data?: IHistoryReadModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.action = _data["action"];
            this.field = _data["field"];
            this.errorCode = _data["errorCode"];
            this.oldValue = _data["oldValue"];
            this.newValue = _data["newValue"];
            this.changeTime = _data["changeTime"] ? new Date(_data["changeTime"].toString()) : <any>undefined;
            this.job = _data["job"] ? JobReadModel.fromJS(_data["job"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HistoryReadModel {
        data = typeof data === 'object' ? data : {};
        let result = new HistoryReadModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["action"] = this.action;
        data["field"] = this.field;
        data["errorCode"] = this.errorCode;
        data["oldValue"] = this.oldValue;
        data["newValue"] = this.newValue;
        data["changeTime"] = this.changeTime ? this.changeTime.toISOString() : <any>undefined;
        data["job"] = this.job ? this.job.toJSON() : <any>undefined;
        return data;
    }
}

export interface IHistoryReadModel {
    id?: string;
    createdAt?: Date;
    action?: string;
    field?: string;
    errorCode?: string;
    oldValue?: string;
    newValue?: string | undefined;
    changeTime?: Date;
    job?: JobReadModel;
}

export class JobReadModel implements IJobReadModel {
    id?: string;
    createdAt?: Date;
    consecutiveNumber?: number;
    title?: string;
    deliveryDate?: Date;
    orderDate?: Date;
    switchJobId?: string;
    jobInfo?: string;
    orderType?: OrderType;
    project?: string;
    easyJob?: string;
    billingOption?: BillingOption;
    status?: Status;
    numberOfFiles?: number;
    customer?: string;
    editor?: UserReadModel;
    client?: ClientReadModel;

    constructor(data?: IJobReadModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.consecutiveNumber = _data["consecutiveNumber"];
            this.title = _data["title"];
            this.deliveryDate = _data["deliveryDate"] ? new Date(_data["deliveryDate"].toString()) : <any>undefined;
            this.orderDate = _data["orderDate"] ? new Date(_data["orderDate"].toString()) : <any>undefined;
            this.switchJobId = _data["switchJobId"];
            this.jobInfo = _data["jobInfo"];
            this.orderType = _data["orderType"];
            this.project = _data["project"];
            this.easyJob = _data["easyJob"];
            this.billingOption = _data["billingOption"];
            this.status = _data["status"];
            this.numberOfFiles = _data["numberOfFiles"];
            this.customer = _data["customer"];
            this.editor = _data["editor"] ? UserReadModel.fromJS(_data["editor"]) : <any>undefined;
            this.client = _data["client"] ? ClientReadModel.fromJS(_data["client"]) : <any>undefined;
        }
    }

    static fromJS(data: any): JobReadModel {
        data = typeof data === 'object' ? data : {};
        let result = new JobReadModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["consecutiveNumber"] = this.consecutiveNumber;
        data["title"] = this.title;
        data["deliveryDate"] = this.deliveryDate ? this.deliveryDate.toISOString() : <any>undefined;
        data["orderDate"] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
        data["switchJobId"] = this.switchJobId;
        data["jobInfo"] = this.jobInfo;
        data["orderType"] = this.orderType;
        data["project"] = this.project;
        data["easyJob"] = this.easyJob;
        data["billingOption"] = this.billingOption;
        data["status"] = this.status;
        data["numberOfFiles"] = this.numberOfFiles;
        data["customer"] = this.customer;
        data["editor"] = this.editor ? this.editor.toJSON() : <any>undefined;
        data["client"] = this.client ? this.client.toJSON() : <any>undefined;
        return data;
    }
}

export interface IJobReadModel {
    id?: string;
    createdAt?: Date;
    consecutiveNumber?: number;
    title?: string;
    deliveryDate?: Date;
    orderDate?: Date;
    switchJobId?: string;
    jobInfo?: string;
    orderType?: OrderType;
    project?: string;
    easyJob?: string;
    billingOption?: BillingOption;
    status?: Status;
    numberOfFiles?: number;
    customer?: string;
    editor?: UserReadModel;
    client?: ClientReadModel;
}

export enum OrderType {
    Important = 0,
    NotImportant = 1,
}

export enum BillingOption {
    Cash = 0,
    CreditCard = 1,
    DebitCard = 2,
    Checks = 3,
}

export enum Status {
    ToDo = 0,
    InProgress = 1,
    Done = 2,
    Transferred2Partner = 3,
}

export class UserReadModel implements IUserReadModel {
    id?: string;
    createdAt?: Date;
    userName?: string;
    firstName?: string;
    lastName?: string;
    email?: string;

    constructor(data?: IUserReadModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.userName = _data["userName"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): UserReadModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserReadModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["userName"] = this.userName;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        return data;
    }
}

export interface IUserReadModel {
    id?: string;
    createdAt?: Date;
    userName?: string;
    firstName?: string;
    lastName?: string;
    email?: string;
}

export class CreateHistoryCommand implements ICreateHistoryCommand {
    action?: string;
    field?: string;
    errorCode?: string;
    oldValue?: string;
    newValue?: string | undefined;
    changeTime?: Date;

    constructor(data?: ICreateHistoryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.action = _data["action"];
            this.field = _data["field"];
            this.errorCode = _data["errorCode"];
            this.oldValue = _data["oldValue"];
            this.newValue = _data["newValue"];
            this.changeTime = _data["changeTime"] ? new Date(_data["changeTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateHistoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateHistoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["action"] = this.action;
        data["field"] = this.field;
        data["errorCode"] = this.errorCode;
        data["oldValue"] = this.oldValue;
        data["newValue"] = this.newValue;
        data["changeTime"] = this.changeTime ? this.changeTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICreateHistoryCommand {
    action?: string;
    field?: string;
    errorCode?: string;
    oldValue?: string;
    newValue?: string | undefined;
    changeTime?: Date;
}

export class UpdateHistoryCommand implements IUpdateHistoryCommand {
    id?: string;
    action?: string;
    field?: string;
    errorCode?: string;
    oldValue?: string;
    newValue?: string | undefined;
    changeTime?: Date;

    constructor(data?: IUpdateHistoryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.action = _data["action"];
            this.field = _data["field"];
            this.errorCode = _data["errorCode"];
            this.oldValue = _data["oldValue"];
            this.newValue = _data["newValue"];
            this.changeTime = _data["changeTime"] ? new Date(_data["changeTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateHistoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateHistoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["action"] = this.action;
        data["field"] = this.field;
        data["errorCode"] = this.errorCode;
        data["oldValue"] = this.oldValue;
        data["newValue"] = this.newValue;
        data["changeTime"] = this.changeTime ? this.changeTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUpdateHistoryCommand {
    id?: string;
    action?: string;
    field?: string;
    errorCode?: string;
    oldValue?: string;
    newValue?: string | undefined;
    changeTime?: Date;
}

export class User implements IUser {
    id?: string;
    createdAt?: Date;
    deletedAt?: Date | undefined;
    userName?: string;
    firstName?: string;
    lastName?: string;
    email?: string;
    history?: History[];
    timeTrackingCreator?: TimeTracking[];
    timeTrackingEditor?: TimeTracking[];
    jobsAsEditor?: Job[];
    jobsAsCreator?: Job[];
    jobFiles?: JobFiles[];
    additionalFile?: AdditionalFile[];

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.userName = _data["userName"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            if (Array.isArray(_data["history"])) {
                this.history = [] as any;
                for (let item of _data["history"])
                    this.history!.push(History.fromJS(item));
            }
            if (Array.isArray(_data["timeTrackingCreator"])) {
                this.timeTrackingCreator = [] as any;
                for (let item of _data["timeTrackingCreator"])
                    this.timeTrackingCreator!.push(TimeTracking.fromJS(item));
            }
            if (Array.isArray(_data["timeTrackingEditor"])) {
                this.timeTrackingEditor = [] as any;
                for (let item of _data["timeTrackingEditor"])
                    this.timeTrackingEditor!.push(TimeTracking.fromJS(item));
            }
            if (Array.isArray(_data["jobsAsEditor"])) {
                this.jobsAsEditor = [] as any;
                for (let item of _data["jobsAsEditor"])
                    this.jobsAsEditor!.push(Job.fromJS(item));
            }
            if (Array.isArray(_data["jobsAsCreator"])) {
                this.jobsAsCreator = [] as any;
                for (let item of _data["jobsAsCreator"])
                    this.jobsAsCreator!.push(Job.fromJS(item));
            }
            if (Array.isArray(_data["jobFiles"])) {
                this.jobFiles = [] as any;
                for (let item of _data["jobFiles"])
                    this.jobFiles!.push(JobFiles.fromJS(item));
            }
            if (Array.isArray(_data["additionalFile"])) {
                this.additionalFile = [] as any;
                for (let item of _data["additionalFile"])
                    this.additionalFile!.push(AdditionalFile.fromJS(item));
            }
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["userName"] = this.userName;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        if (Array.isArray(this.history)) {
            data["history"] = [];
            for (let item of this.history)
                data["history"].push(item.toJSON());
        }
        if (Array.isArray(this.timeTrackingCreator)) {
            data["timeTrackingCreator"] = [];
            for (let item of this.timeTrackingCreator)
                data["timeTrackingCreator"].push(item.toJSON());
        }
        if (Array.isArray(this.timeTrackingEditor)) {
            data["timeTrackingEditor"] = [];
            for (let item of this.timeTrackingEditor)
                data["timeTrackingEditor"].push(item.toJSON());
        }
        if (Array.isArray(this.jobsAsEditor)) {
            data["jobsAsEditor"] = [];
            for (let item of this.jobsAsEditor)
                data["jobsAsEditor"].push(item.toJSON());
        }
        if (Array.isArray(this.jobsAsCreator)) {
            data["jobsAsCreator"] = [];
            for (let item of this.jobsAsCreator)
                data["jobsAsCreator"].push(item.toJSON());
        }
        if (Array.isArray(this.jobFiles)) {
            data["jobFiles"] = [];
            for (let item of this.jobFiles)
                data["jobFiles"].push(item.toJSON());
        }
        if (Array.isArray(this.additionalFile)) {
            data["additionalFile"] = [];
            for (let item of this.additionalFile)
                data["additionalFile"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUser {
    id?: string;
    createdAt?: Date;
    deletedAt?: Date | undefined;
    userName?: string;
    firstName?: string;
    lastName?: string;
    email?: string;
    history?: History[];
    timeTrackingCreator?: TimeTracking[];
    timeTrackingEditor?: TimeTracking[];
    jobsAsEditor?: Job[];
    jobsAsCreator?: Job[];
    jobFiles?: JobFiles[];
    additionalFile?: AdditionalFile[];
}

export class History implements IHistory {
    id?: string;
    createdAt?: Date;
    deletedAt?: Date | undefined;
    action?: string;
    field?: string;
    errorCode?: string;
    oldValue?: string;
    newValue?: string | undefined;
    changeTime?: Date;
    editorId?: string;
    editor?: User | undefined;
    jobId?: string;
    job?: Job | undefined;

    constructor(data?: IHistory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.action = _data["action"];
            this.field = _data["field"];
            this.errorCode = _data["errorCode"];
            this.oldValue = _data["oldValue"];
            this.newValue = _data["newValue"];
            this.changeTime = _data["changeTime"] ? new Date(_data["changeTime"].toString()) : <any>undefined;
            this.editorId = _data["editorId"];
            this.editor = _data["editor"] ? User.fromJS(_data["editor"]) : <any>undefined;
            this.jobId = _data["jobId"];
            this.job = _data["job"] ? Job.fromJS(_data["job"]) : <any>undefined;
        }
    }

    static fromJS(data: any): History {
        data = typeof data === 'object' ? data : {};
        let result = new History();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["action"] = this.action;
        data["field"] = this.field;
        data["errorCode"] = this.errorCode;
        data["oldValue"] = this.oldValue;
        data["newValue"] = this.newValue;
        data["changeTime"] = this.changeTime ? this.changeTime.toISOString() : <any>undefined;
        data["editorId"] = this.editorId;
        data["editor"] = this.editor ? this.editor.toJSON() : <any>undefined;
        data["jobId"] = this.jobId;
        data["job"] = this.job ? this.job.toJSON() : <any>undefined;
        return data;
    }
}

export interface IHistory {
    id?: string;
    createdAt?: Date;
    deletedAt?: Date | undefined;
    action?: string;
    field?: string;
    errorCode?: string;
    oldValue?: string;
    newValue?: string | undefined;
    changeTime?: Date;
    editorId?: string;
    editor?: User | undefined;
    jobId?: string;
    job?: Job | undefined;
}

export class Job implements IJob {
    id?: string;
    createdAt?: Date;
    deletedAt?: Date | undefined;
    consecutiveNumber?: number;
    title?: string;
    deliveryDate?: Date;
    orderDate?: Date;
    switchJobId?: string;
    jobInfo?: string;
    orderType?: OrderType;
    project?: string;
    easyJob?: string;
    billingOption?: BillingOption;
    status?: Status;
    numberOfFiles?: number;
    customer?: string;
    jobFiles?: JobFiles[];
    history?: History[];
    additionalFile?: AdditionalFile[];
    timeTracking?: TimeTracking[];
    creatorId?: string;
    creator?: User | undefined;
    editorId?: string | undefined;
    editor?: User | undefined;
    clientId?: string;
    client?: Client | undefined;

    constructor(data?: IJob) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.consecutiveNumber = _data["consecutiveNumber"];
            this.title = _data["title"];
            this.deliveryDate = _data["deliveryDate"] ? new Date(_data["deliveryDate"].toString()) : <any>undefined;
            this.orderDate = _data["orderDate"] ? new Date(_data["orderDate"].toString()) : <any>undefined;
            this.switchJobId = _data["switchJobId"];
            this.jobInfo = _data["jobInfo"];
            this.orderType = _data["orderType"];
            this.project = _data["project"];
            this.easyJob = _data["easyJob"];
            this.billingOption = _data["billingOption"];
            this.status = _data["status"];
            this.numberOfFiles = _data["numberOfFiles"];
            this.customer = _data["customer"];
            if (Array.isArray(_data["jobFiles"])) {
                this.jobFiles = [] as any;
                for (let item of _data["jobFiles"])
                    this.jobFiles!.push(JobFiles.fromJS(item));
            }
            if (Array.isArray(_data["history"])) {
                this.history = [] as any;
                for (let item of _data["history"])
                    this.history!.push(History.fromJS(item));
            }
            if (Array.isArray(_data["additionalFile"])) {
                this.additionalFile = [] as any;
                for (let item of _data["additionalFile"])
                    this.additionalFile!.push(AdditionalFile.fromJS(item));
            }
            if (Array.isArray(_data["timeTracking"])) {
                this.timeTracking = [] as any;
                for (let item of _data["timeTracking"])
                    this.timeTracking!.push(TimeTracking.fromJS(item));
            }
            this.creatorId = _data["creatorId"];
            this.creator = _data["creator"] ? User.fromJS(_data["creator"]) : <any>undefined;
            this.editorId = _data["editorId"];
            this.editor = _data["editor"] ? User.fromJS(_data["editor"]) : <any>undefined;
            this.clientId = _data["clientId"];
            this.client = _data["client"] ? Client.fromJS(_data["client"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Job {
        data = typeof data === 'object' ? data : {};
        let result = new Job();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["consecutiveNumber"] = this.consecutiveNumber;
        data["title"] = this.title;
        data["deliveryDate"] = this.deliveryDate ? this.deliveryDate.toISOString() : <any>undefined;
        data["orderDate"] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
        data["switchJobId"] = this.switchJobId;
        data["jobInfo"] = this.jobInfo;
        data["orderType"] = this.orderType;
        data["project"] = this.project;
        data["easyJob"] = this.easyJob;
        data["billingOption"] = this.billingOption;
        data["status"] = this.status;
        data["numberOfFiles"] = this.numberOfFiles;
        data["customer"] = this.customer;
        if (Array.isArray(this.jobFiles)) {
            data["jobFiles"] = [];
            for (let item of this.jobFiles)
                data["jobFiles"].push(item.toJSON());
        }
        if (Array.isArray(this.history)) {
            data["history"] = [];
            for (let item of this.history)
                data["history"].push(item.toJSON());
        }
        if (Array.isArray(this.additionalFile)) {
            data["additionalFile"] = [];
            for (let item of this.additionalFile)
                data["additionalFile"].push(item.toJSON());
        }
        if (Array.isArray(this.timeTracking)) {
            data["timeTracking"] = [];
            for (let item of this.timeTracking)
                data["timeTracking"].push(item.toJSON());
        }
        data["creatorId"] = this.creatorId;
        data["creator"] = this.creator ? this.creator.toJSON() : <any>undefined;
        data["editorId"] = this.editorId;
        data["editor"] = this.editor ? this.editor.toJSON() : <any>undefined;
        data["clientId"] = this.clientId;
        data["client"] = this.client ? this.client.toJSON() : <any>undefined;
        return data;
    }
}

export interface IJob {
    id?: string;
    createdAt?: Date;
    deletedAt?: Date | undefined;
    consecutiveNumber?: number;
    title?: string;
    deliveryDate?: Date;
    orderDate?: Date;
    switchJobId?: string;
    jobInfo?: string;
    orderType?: OrderType;
    project?: string;
    easyJob?: string;
    billingOption?: BillingOption;
    status?: Status;
    numberOfFiles?: number;
    customer?: string;
    jobFiles?: JobFiles[];
    history?: History[];
    additionalFile?: AdditionalFile[];
    timeTracking?: TimeTracking[];
    creatorId?: string;
    creator?: User | undefined;
    editorId?: string | undefined;
    editor?: User | undefined;
    clientId?: string;
    client?: Client | undefined;
}

export class JobFiles implements IJobFiles {
    id?: string;
    createdAt?: Date;
    deletedAt?: Date | undefined;
    switchJobField?: string;
    originalFilename?: string;
    editedFilename?: string;
    fileExtension?: string;
    status?: Status;
    fileProperties?: string;
    thumbnail?: string;
    storageType?: string;
    source?: string;
    errorCode?: string;
    errorMessage?: string;
    creatorId?: string;
    creator?: User | undefined;
    jobId?: string;
    job?: Job | undefined;
    filePath?: FilePath | undefined;
    activityId?: string | undefined;
    activity?: Activity | undefined;

    constructor(data?: IJobFiles) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.switchJobField = _data["switchJobField"];
            this.originalFilename = _data["originalFilename"];
            this.editedFilename = _data["editedFilename"];
            this.fileExtension = _data["fileExtension"];
            this.status = _data["status"];
            this.fileProperties = _data["fileProperties"];
            this.thumbnail = _data["thumbnail"];
            this.storageType = _data["storageType"];
            this.source = _data["source"];
            this.errorCode = _data["errorCode"];
            this.errorMessage = _data["errorMessage"];
            this.creatorId = _data["creatorId"];
            this.creator = _data["creator"] ? User.fromJS(_data["creator"]) : <any>undefined;
            this.jobId = _data["jobId"];
            this.job = _data["job"] ? Job.fromJS(_data["job"]) : <any>undefined;
            this.filePath = _data["filePath"] ? FilePath.fromJS(_data["filePath"]) : <any>undefined;
            this.activityId = _data["activityId"];
            this.activity = _data["activity"] ? Activity.fromJS(_data["activity"]) : <any>undefined;
        }
    }

    static fromJS(data: any): JobFiles {
        data = typeof data === 'object' ? data : {};
        let result = new JobFiles();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["switchJobField"] = this.switchJobField;
        data["originalFilename"] = this.originalFilename;
        data["editedFilename"] = this.editedFilename;
        data["fileExtension"] = this.fileExtension;
        data["status"] = this.status;
        data["fileProperties"] = this.fileProperties;
        data["thumbnail"] = this.thumbnail;
        data["storageType"] = this.storageType;
        data["source"] = this.source;
        data["errorCode"] = this.errorCode;
        data["errorMessage"] = this.errorMessage;
        data["creatorId"] = this.creatorId;
        data["creator"] = this.creator ? this.creator.toJSON() : <any>undefined;
        data["jobId"] = this.jobId;
        data["job"] = this.job ? this.job.toJSON() : <any>undefined;
        data["filePath"] = this.filePath ? this.filePath.toJSON() : <any>undefined;
        data["activityId"] = this.activityId;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        return data;
    }
}

export interface IJobFiles {
    id?: string;
    createdAt?: Date;
    deletedAt?: Date | undefined;
    switchJobField?: string;
    originalFilename?: string;
    editedFilename?: string;
    fileExtension?: string;
    status?: Status;
    fileProperties?: string;
    thumbnail?: string;
    storageType?: string;
    source?: string;
    errorCode?: string;
    errorMessage?: string;
    creatorId?: string;
    creator?: User | undefined;
    jobId?: string;
    job?: Job | undefined;
    filePath?: FilePath | undefined;
    activityId?: string | undefined;
    activity?: Activity | undefined;
}

export class FilePath implements IFilePath {
    id?: string;
    createdAt?: Date;
    deletedAt?: Date | undefined;
    windowsPath?: string;
    macPath?: string;
    ebvFileaction?: string;
    jobFileId?: string;
    jobFiles?: JobFiles;
    additionalFileId?: string;
    additionalFile?: AdditionalFile;

    constructor(data?: IFilePath) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.windowsPath = _data["windowsPath"];
            this.macPath = _data["macPath"];
            this.ebvFileaction = _data["ebvFileaction"];
            this.jobFileId = _data["jobFileId"];
            this.jobFiles = _data["jobFiles"] ? JobFiles.fromJS(_data["jobFiles"]) : <any>undefined;
            this.additionalFileId = _data["additionalFileId"];
            this.additionalFile = _data["additionalFile"] ? AdditionalFile.fromJS(_data["additionalFile"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FilePath {
        data = typeof data === 'object' ? data : {};
        let result = new FilePath();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["windowsPath"] = this.windowsPath;
        data["macPath"] = this.macPath;
        data["ebvFileaction"] = this.ebvFileaction;
        data["jobFileId"] = this.jobFileId;
        data["jobFiles"] = this.jobFiles ? this.jobFiles.toJSON() : <any>undefined;
        data["additionalFileId"] = this.additionalFileId;
        data["additionalFile"] = this.additionalFile ? this.additionalFile.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFilePath {
    id?: string;
    createdAt?: Date;
    deletedAt?: Date | undefined;
    windowsPath?: string;
    macPath?: string;
    ebvFileaction?: string;
    jobFileId?: string;
    jobFiles?: JobFiles;
    additionalFileId?: string;
    additionalFile?: AdditionalFile;
}

export class AdditionalFile implements IAdditionalFile {
    id?: string;
    createdAt?: Date;
    deletedAt?: Date | undefined;
    title?: string;
    creatorId?: string;
    creator?: User | undefined;
    jobId?: string;
    job?: Job | undefined;
    filePath?: FilePath | undefined;

    constructor(data?: IAdditionalFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.creatorId = _data["creatorId"];
            this.creator = _data["creator"] ? User.fromJS(_data["creator"]) : <any>undefined;
            this.jobId = _data["jobId"];
            this.job = _data["job"] ? Job.fromJS(_data["job"]) : <any>undefined;
            this.filePath = _data["filePath"] ? FilePath.fromJS(_data["filePath"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AdditionalFile {
        data = typeof data === 'object' ? data : {};
        let result = new AdditionalFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["creatorId"] = this.creatorId;
        data["creator"] = this.creator ? this.creator.toJSON() : <any>undefined;
        data["jobId"] = this.jobId;
        data["job"] = this.job ? this.job.toJSON() : <any>undefined;
        data["filePath"] = this.filePath ? this.filePath.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAdditionalFile {
    id?: string;
    createdAt?: Date;
    deletedAt?: Date | undefined;
    title?: string;
    creatorId?: string;
    creator?: User | undefined;
    jobId?: string;
    job?: Job | undefined;
    filePath?: FilePath | undefined;
}

export class Activity implements IActivity {
    id?: string;
    createdAt?: Date;
    deletedAt?: Date | undefined;
    customer?: string;
    serviceType?: string;
    quality?: string;
    jobFiles?: JobFiles[];

    constructor(data?: IActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.customer = _data["customer"];
            this.serviceType = _data["serviceType"];
            this.quality = _data["quality"];
            if (Array.isArray(_data["jobFiles"])) {
                this.jobFiles = [] as any;
                for (let item of _data["jobFiles"])
                    this.jobFiles!.push(JobFiles.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Activity {
        data = typeof data === 'object' ? data : {};
        let result = new Activity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["customer"] = this.customer;
        data["serviceType"] = this.serviceType;
        data["quality"] = this.quality;
        if (Array.isArray(this.jobFiles)) {
            data["jobFiles"] = [];
            for (let item of this.jobFiles)
                data["jobFiles"].push(item.toJSON());
        }
        return data;
    }
}

export interface IActivity {
    id?: string;
    createdAt?: Date;
    deletedAt?: Date | undefined;
    customer?: string;
    serviceType?: string;
    quality?: string;
    jobFiles?: JobFiles[];
}

export class TimeTracking implements ITimeTracking {
    id?: string;
    createdAt?: Date;
    deletedAt?: Date | undefined;
    startedOn?: Date;
    workingDuration?: string;
    creatorId?: string;
    creator?: User | undefined;
    editorId?: string;
    editor?: User | undefined;
    jobId?: string;
    job?: Job | undefined;

    constructor(data?: ITimeTracking) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.startedOn = _data["startedOn"] ? new Date(_data["startedOn"].toString()) : <any>undefined;
            this.workingDuration = _data["workingDuration"];
            this.creatorId = _data["creatorId"];
            this.creator = _data["creator"] ? User.fromJS(_data["creator"]) : <any>undefined;
            this.editorId = _data["editorId"];
            this.editor = _data["editor"] ? User.fromJS(_data["editor"]) : <any>undefined;
            this.jobId = _data["jobId"];
            this.job = _data["job"] ? Job.fromJS(_data["job"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TimeTracking {
        data = typeof data === 'object' ? data : {};
        let result = new TimeTracking();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["startedOn"] = this.startedOn ? this.startedOn.toISOString() : <any>undefined;
        data["workingDuration"] = this.workingDuration;
        data["creatorId"] = this.creatorId;
        data["creator"] = this.creator ? this.creator.toJSON() : <any>undefined;
        data["editorId"] = this.editorId;
        data["editor"] = this.editor ? this.editor.toJSON() : <any>undefined;
        data["jobId"] = this.jobId;
        data["job"] = this.job ? this.job.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITimeTracking {
    id?: string;
    createdAt?: Date;
    deletedAt?: Date | undefined;
    startedOn?: Date;
    workingDuration?: string;
    creatorId?: string;
    creator?: User | undefined;
    editorId?: string;
    editor?: User | undefined;
    jobId?: string;
    job?: Job | undefined;
}

export class Client implements IClient {
    id?: string;
    createdAt?: Date;
    deletedAt?: Date | undefined;
    email?: string;
    shortcut?: string;
    firstName?: string;
    lastName?: string;
    job?: Job[];

    constructor(data?: IClient) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.email = _data["email"];
            this.shortcut = _data["shortcut"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            if (Array.isArray(_data["job"])) {
                this.job = [] as any;
                for (let item of _data["job"])
                    this.job!.push(Job.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Client {
        data = typeof data === 'object' ? data : {};
        let result = new Client();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["email"] = this.email;
        data["shortcut"] = this.shortcut;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        if (Array.isArray(this.job)) {
            data["job"] = [];
            for (let item of this.job)
                data["job"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClient {
    id?: string;
    createdAt?: Date;
    deletedAt?: Date | undefined;
    email?: string;
    shortcut?: string;
    firstName?: string;
    lastName?: string;
    job?: Job[];
}

export class CreateJobCommand implements ICreateJobCommand {
    consecutiveNumber?: number;
    title?: string;
    deliveryDate?: Date;
    orderDate?: Date;
    switchJobId?: string;
    jobInfo?: string;
    orderType?: OrderType;
    project?: string;
    easyJob?: string;
    billingOption?: BillingOption;
    numberOfFiles?: number;
    customer?: string;

    constructor(data?: ICreateJobCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.consecutiveNumber = _data["consecutiveNumber"];
            this.title = _data["title"];
            this.deliveryDate = _data["deliveryDate"] ? new Date(_data["deliveryDate"].toString()) : <any>undefined;
            this.orderDate = _data["orderDate"] ? new Date(_data["orderDate"].toString()) : <any>undefined;
            this.switchJobId = _data["switchJobId"];
            this.jobInfo = _data["jobInfo"];
            this.orderType = _data["orderType"];
            this.project = _data["project"];
            this.easyJob = _data["easyJob"];
            this.billingOption = _data["billingOption"];
            this.numberOfFiles = _data["numberOfFiles"];
            this.customer = _data["customer"];
        }
    }

    static fromJS(data: any): CreateJobCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateJobCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consecutiveNumber"] = this.consecutiveNumber;
        data["title"] = this.title;
        data["deliveryDate"] = this.deliveryDate ? this.deliveryDate.toISOString() : <any>undefined;
        data["orderDate"] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
        data["switchJobId"] = this.switchJobId;
        data["jobInfo"] = this.jobInfo;
        data["orderType"] = this.orderType;
        data["project"] = this.project;
        data["easyJob"] = this.easyJob;
        data["billingOption"] = this.billingOption;
        data["numberOfFiles"] = this.numberOfFiles;
        data["customer"] = this.customer;
        return data;
    }
}

export interface ICreateJobCommand {
    consecutiveNumber?: number;
    title?: string;
    deliveryDate?: Date;
    orderDate?: Date;
    switchJobId?: string;
    jobInfo?: string;
    orderType?: OrderType;
    project?: string;
    easyJob?: string;
    billingOption?: BillingOption;
    numberOfFiles?: number;
    customer?: string;
}

export class UpdateJobCommand implements IUpdateJobCommand {
    id?: string;
    consecutiveNumber?: number;
    title?: string;
    deliveryDate?: Date;
    orderDate?: Date;
    switchJobId?: string;
    jobInfo?: string;
    orderType?: OrderType;
    project?: string;
    easyJob?: string;
    billingOption?: BillingOption;
    status?: Status;
    numberOfFiles?: number;
    customer?: string;

    constructor(data?: IUpdateJobCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.consecutiveNumber = _data["consecutiveNumber"];
            this.title = _data["title"];
            this.deliveryDate = _data["deliveryDate"] ? new Date(_data["deliveryDate"].toString()) : <any>undefined;
            this.orderDate = _data["orderDate"] ? new Date(_data["orderDate"].toString()) : <any>undefined;
            this.switchJobId = _data["switchJobId"];
            this.jobInfo = _data["jobInfo"];
            this.orderType = _data["orderType"];
            this.project = _data["project"];
            this.easyJob = _data["easyJob"];
            this.billingOption = _data["billingOption"];
            this.status = _data["status"];
            this.numberOfFiles = _data["numberOfFiles"];
            this.customer = _data["customer"];
        }
    }

    static fromJS(data: any): UpdateJobCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateJobCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["consecutiveNumber"] = this.consecutiveNumber;
        data["title"] = this.title;
        data["deliveryDate"] = this.deliveryDate ? this.deliveryDate.toISOString() : <any>undefined;
        data["orderDate"] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
        data["switchJobId"] = this.switchJobId;
        data["jobInfo"] = this.jobInfo;
        data["orderType"] = this.orderType;
        data["project"] = this.project;
        data["easyJob"] = this.easyJob;
        data["billingOption"] = this.billingOption;
        data["status"] = this.status;
        data["numberOfFiles"] = this.numberOfFiles;
        data["customer"] = this.customer;
        return data;
    }
}

export interface IUpdateJobCommand {
    id?: string;
    consecutiveNumber?: number;
    title?: string;
    deliveryDate?: Date;
    orderDate?: Date;
    switchJobId?: string;
    jobInfo?: string;
    orderType?: OrderType;
    project?: string;
    easyJob?: string;
    billingOption?: BillingOption;
    status?: Status;
    numberOfFiles?: number;
    customer?: string;
}

export class UpdateJobEditorCommand implements IUpdateJobEditorCommand {
    id?: string;
    userName?: string;
    firstName?: string;
    lastName?: string;
    email?: string;

    constructor(data?: IUpdateJobEditorCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): UpdateJobEditorCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateJobEditorCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        return data;
    }
}

export interface IUpdateJobEditorCommand {
    id?: string;
    userName?: string;
    firstName?: string;
    lastName?: string;
    email?: string;
}

export class JobFileReadModel implements IJobFileReadModel {
    id?: string;
    createdAt?: Date;
    switchJobField?: string;
    originalFilename?: string;
    editedFilename?: string;
    fileExtension?: string;
    status?: Status;
    fileProperties?: string;
    thumbnail?: string;
    storageType?: string;
    source?: string;
    errorCode?: string;
    errorMessage?: string;
    job?: JobReadModel;
    filePath?: FilePathReadModel;
    activity?: ActivityReadModel | undefined;

    constructor(data?: IJobFileReadModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.switchJobField = _data["switchJobField"];
            this.originalFilename = _data["originalFilename"];
            this.editedFilename = _data["editedFilename"];
            this.fileExtension = _data["fileExtension"];
            this.status = _data["status"];
            this.fileProperties = _data["fileProperties"];
            this.thumbnail = _data["thumbnail"];
            this.storageType = _data["storageType"];
            this.source = _data["source"];
            this.errorCode = _data["errorCode"];
            this.errorMessage = _data["errorMessage"];
            this.job = _data["job"] ? JobReadModel.fromJS(_data["job"]) : <any>undefined;
            this.filePath = _data["filePath"] ? FilePathReadModel.fromJS(_data["filePath"]) : <any>undefined;
            this.activity = _data["activity"] ? ActivityReadModel.fromJS(_data["activity"]) : <any>undefined;
        }
    }

    static fromJS(data: any): JobFileReadModel {
        data = typeof data === 'object' ? data : {};
        let result = new JobFileReadModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["switchJobField"] = this.switchJobField;
        data["originalFilename"] = this.originalFilename;
        data["editedFilename"] = this.editedFilename;
        data["fileExtension"] = this.fileExtension;
        data["status"] = this.status;
        data["fileProperties"] = this.fileProperties;
        data["thumbnail"] = this.thumbnail;
        data["storageType"] = this.storageType;
        data["source"] = this.source;
        data["errorCode"] = this.errorCode;
        data["errorMessage"] = this.errorMessage;
        data["job"] = this.job ? this.job.toJSON() : <any>undefined;
        data["filePath"] = this.filePath ? this.filePath.toJSON() : <any>undefined;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        return data;
    }
}

export interface IJobFileReadModel {
    id?: string;
    createdAt?: Date;
    switchJobField?: string;
    originalFilename?: string;
    editedFilename?: string;
    fileExtension?: string;
    status?: Status;
    fileProperties?: string;
    thumbnail?: string;
    storageType?: string;
    source?: string;
    errorCode?: string;
    errorMessage?: string;
    job?: JobReadModel;
    filePath?: FilePathReadModel;
    activity?: ActivityReadModel | undefined;
}

export class FilePathReadModel implements IFilePathReadModel {
    id?: string;
    createdAt?: Date;
    windowsPath?: string;
    macPath?: string;
    ebvFileaction?: string;

    constructor(data?: IFilePathReadModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.windowsPath = _data["windowsPath"];
            this.macPath = _data["macPath"];
            this.ebvFileaction = _data["ebvFileaction"];
        }
    }

    static fromJS(data: any): FilePathReadModel {
        data = typeof data === 'object' ? data : {};
        let result = new FilePathReadModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["windowsPath"] = this.windowsPath;
        data["macPath"] = this.macPath;
        data["ebvFileaction"] = this.ebvFileaction;
        return data;
    }
}

export interface IFilePathReadModel {
    id?: string;
    createdAt?: Date;
    windowsPath?: string;
    macPath?: string;
    ebvFileaction?: string;
}

export class CreateJobFileCommand implements ICreateJobFileCommand {
    switchJobField?: string;
    originalFilename?: string;
    editedFilename?: string;
    fileExtension?: string;
    status?: Status;
    fileProperties?: string;
    thumbnail?: string;
    storageType?: string;
    source?: string;
    errorCode?: string;
    errorMessage?: string;

    constructor(data?: ICreateJobFileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.switchJobField = _data["switchJobField"];
            this.originalFilename = _data["originalFilename"];
            this.editedFilename = _data["editedFilename"];
            this.fileExtension = _data["fileExtension"];
            this.status = _data["status"];
            this.fileProperties = _data["fileProperties"];
            this.thumbnail = _data["thumbnail"];
            this.storageType = _data["storageType"];
            this.source = _data["source"];
            this.errorCode = _data["errorCode"];
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): CreateJobFileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateJobFileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["switchJobField"] = this.switchJobField;
        data["originalFilename"] = this.originalFilename;
        data["editedFilename"] = this.editedFilename;
        data["fileExtension"] = this.fileExtension;
        data["status"] = this.status;
        data["fileProperties"] = this.fileProperties;
        data["thumbnail"] = this.thumbnail;
        data["storageType"] = this.storageType;
        data["source"] = this.source;
        data["errorCode"] = this.errorCode;
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

export interface ICreateJobFileCommand {
    switchJobField?: string;
    originalFilename?: string;
    editedFilename?: string;
    fileExtension?: string;
    status?: Status;
    fileProperties?: string;
    thumbnail?: string;
    storageType?: string;
    source?: string;
    errorCode?: string;
    errorMessage?: string;
}

export class UpdateJobFileCommand implements IUpdateJobFileCommand {
    id?: string;
    switchJobField?: string;
    originalFilename?: string;
    editedFilename?: string;
    fileExtension?: string;
    status?: Status;
    fileProperties?: string;
    thumbnail?: string;
    storageType?: string;
    source?: string;
    errorCode?: string;
    errorMessage?: string;

    constructor(data?: IUpdateJobFileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.switchJobField = _data["switchJobField"];
            this.originalFilename = _data["originalFilename"];
            this.editedFilename = _data["editedFilename"];
            this.fileExtension = _data["fileExtension"];
            this.status = _data["status"];
            this.fileProperties = _data["fileProperties"];
            this.thumbnail = _data["thumbnail"];
            this.storageType = _data["storageType"];
            this.source = _data["source"];
            this.errorCode = _data["errorCode"];
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): UpdateJobFileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateJobFileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["switchJobField"] = this.switchJobField;
        data["originalFilename"] = this.originalFilename;
        data["editedFilename"] = this.editedFilename;
        data["fileExtension"] = this.fileExtension;
        data["status"] = this.status;
        data["fileProperties"] = this.fileProperties;
        data["thumbnail"] = this.thumbnail;
        data["storageType"] = this.storageType;
        data["source"] = this.source;
        data["errorCode"] = this.errorCode;
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

export interface IUpdateJobFileCommand {
    id?: string;
    switchJobField?: string;
    originalFilename?: string;
    editedFilename?: string;
    fileExtension?: string;
    status?: Status;
    fileProperties?: string;
    thumbnail?: string;
    storageType?: string;
    source?: string;
    errorCode?: string;
    errorMessage?: string;
}

export class TimeTrackingReadModel implements ITimeTrackingReadModel {
    id?: string;
    createdAt?: Date;
    startedOn?: Date;
    workingDuration?: string;

    constructor(data?: ITimeTrackingReadModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.startedOn = _data["startedOn"] ? new Date(_data["startedOn"].toString()) : <any>undefined;
            this.workingDuration = _data["workingDuration"];
        }
    }

    static fromJS(data: any): TimeTrackingReadModel {
        data = typeof data === 'object' ? data : {};
        let result = new TimeTrackingReadModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["startedOn"] = this.startedOn ? this.startedOn.toISOString() : <any>undefined;
        data["workingDuration"] = this.workingDuration;
        return data;
    }
}

export interface ITimeTrackingReadModel {
    id?: string;
    createdAt?: Date;
    startedOn?: Date;
    workingDuration?: string;
}

export class CreateTimeTrackingCommand implements ICreateTimeTrackingCommand {
    startedOn?: Date;
    workingDuration?: string;

    constructor(data?: ICreateTimeTrackingCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startedOn = _data["startedOn"] ? new Date(_data["startedOn"].toString()) : <any>undefined;
            this.workingDuration = _data["workingDuration"];
        }
    }

    static fromJS(data: any): CreateTimeTrackingCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTimeTrackingCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startedOn"] = this.startedOn ? this.startedOn.toISOString() : <any>undefined;
        data["workingDuration"] = this.workingDuration;
        return data;
    }
}

export interface ICreateTimeTrackingCommand {
    startedOn?: Date;
    workingDuration?: string;
}

export class UpdateTimeTrackingCommand implements IUpdateTimeTrackingCommand {
    id?: string;
    startedOn?: Date;
    workingDuration?: string;

    constructor(data?: IUpdateTimeTrackingCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.startedOn = _data["startedOn"] ? new Date(_data["startedOn"].toString()) : <any>undefined;
            this.workingDuration = _data["workingDuration"];
        }
    }

    static fromJS(data: any): UpdateTimeTrackingCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTimeTrackingCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["startedOn"] = this.startedOn ? this.startedOn.toISOString() : <any>undefined;
        data["workingDuration"] = this.workingDuration;
        return data;
    }
}

export interface IUpdateTimeTrackingCommand {
    id?: string;
    startedOn?: Date;
    workingDuration?: string;
}

export class CreateUserCommand implements ICreateUserCommand {
    userName?: string;
    firstName?: string;
    lastName?: string;
    email?: string;

    constructor(data?: ICreateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): CreateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        return data;
    }
}

export interface ICreateUserCommand {
    userName?: string;
    firstName?: string;
    lastName?: string;
    email?: string;
}

export class UpdateUserCommand implements IUpdateUserCommand {
    id?: string;
    userName?: string;
    firstName?: string;
    lastName?: string;
    email?: string;

    constructor(data?: IUpdateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): UpdateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        return data;
    }
}

export interface IUpdateUserCommand {
    id?: string;
    userName?: string;
    firstName?: string;
    lastName?: string;
    email?: string;
}

export class WeatherForecast implements IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.temperatureC = _data["temperatureC"];
            this.temperatureF = _data["temperatureF"];
            this.summary = _data["summary"];
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? formatDate(this.date) : <any>undefined;
        data["temperatureC"] = this.temperatureC;
        data["temperatureF"] = this.temperatureF;
        data["summary"] = this.summary;
        return data;
    }
}

export interface IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}